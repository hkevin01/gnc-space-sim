/**
 * TypeScript wrapper for Enhanced SSSP WebAssembly module
 *
 * Provides seamless integration between the Rust WASM implementation
 * and the TypeScript GNC system for spacecraft trajectory planning.
 */

import { LaunchPhase } from '../launch/guidance-new'
import { Vec3 } from '../orbits/twobody'

// Type definitions for WASM module (will be generated by wasm-pack)
declare class WasmSparseGraph {
  constructor(nodeCount: number, outgoingEdges: Uint32Array, destinations: Uint32Array, weights: Float64Array)
  readonly node_count: number
  readonly edge_count: number
  validate(): boolean
}

declare class WasmEnhancedSSSpSolver {
  constructor(graph: WasmSparseGraph)
  preprocess(): boolean
  solve(source: number): WasmSSSpResult
}

declare class WasmSSSpResult {
  readonly distances: Float64Array
  readonly predecessors: Int32Array
  readonly nodes_visited: number
  readonly edges_relaxed: number
  readonly wall_time_ms: number
  readonly algorithm_used: string
}

declare class WasmTrajectoryGraphBuilder {
  static build_trajectory_graph(
    positionResolution: number,
    velocityResolution: number,
    timeSteps: number,
    maxThrust: number,
    specificImpulse: number
  ): WasmSparseGraph
}

declare function benchmark_algorithms(
  graph: WasmSparseGraph,
  source: number,
  iterations: number
): {
  enhancedTimeMs: number
  dijkstraTimeMs: number
  speedupFactor: number
  iterations: number
}

/**
 * Spacecraft trajectory planning configuration
 */
export interface TrajectoryPlanningConfig {
  // State space bounds
  positionBounds: {
    min: Vec3
    max: Vec3
  }
  velocityBounds: {
    min: Vec3
    max: Vec3
  }

  // Temporal parameters
  timeHorizon: number      // seconds
  timeStep: number         // seconds

  // Vehicle parameters
  fuelCapacity: number     // kg
  maxThrust: number        // N
  specificImpulse: number  // seconds
  dryMass: number         // kg

  // Cost function weights
  costs: {
    timeWeight: number     // Cost per second
    fuelWeight: number     // Cost per kg fuel
    riskWeight: number     // Risk factor multiplier
  }

  // Discretization resolution
  resolution: {
    position: number       // Grid points per dimension
    velocity: number       // Grid points per dimension
  }
}

/**
 * Spacecraft state representation for trajectory planning
 */
export interface SpacecraftState {
  position: Vec3           // m, ECEF coordinates
  velocity: Vec3           // m/s, ECEF velocity
  time: number            // s, mission time
  fuelMass: number        // kg, remaining fuel
  phase: LaunchPhase      // Current mission phase
}

/**
 * Trajectory planning result
 */
export interface TrajectoryPlan {
  states: SpacecraftState[]     // Optimal trajectory states
  maneuvers: TrajectoryManeuver[] // Required maneuvers
  totalCost: number             // Total trajectory cost
  planningTime: number          // ms, time to compute plan
  algorithm: string             // Algorithm used
  performance: {
    nodesVisited: number
    edgesRelaxed: number
    speedupFactor?: number      // vs Dijkstra baseline
  }
}

/**
 * Trajectory maneuver description
 */
export interface TrajectoryManeuver {
  time: number              // s, execution time
  deltaV: Vec3             // m/s, velocity change
  burnDuration: number     // s, burn time
  fuelUsed: number         // kg, propellant consumed
  cost: number             // Maneuver cost
}

/**
 * Enhanced trajectory planner using breakthrough SSSP algorithm
 */
export class EnhancedTrajectoryPlanner {
  private wasmModule: any = null
  private solver: WasmEnhancedSSSpSolver | null = null
  private graph: WasmSparseGraph | null = null
  private config: TrajectoryPlanningConfig
  private nodeToStateCache: Map<number, SpacecraftState> = new Map()

  constructor(config: TrajectoryPlanningConfig) {
    this.config = config
  }

  /**
   * Initialize WASM module and preprocess graph
   */
  async initialize(): Promise<void> {
    try {
      // Load WASM module (would be actual import in production)
      // this.wasmModule = await import('@gnc/rust')

      console.log('Building trajectory graph...')
      this.buildTrajectoryGraph()

      if (this.graph && this.wasmModule) {
        console.log('Initializing enhanced SSSP solver...')
        this.solver = new this.wasmModule.EnhancedSSSpSolver(this.graph)

        // Preprocess for accelerated queries
        const preprocessed = this.solver.preprocess()
        if (!preprocessed) {
          throw new Error('Graph preprocessing failed')
        }

        console.log('Enhanced trajectory planner initialized successfully')
      }
    } catch (error) {
      console.error('Failed to initialize trajectory planner:', error)
      throw error
    }
  }

  /**
   * Plan optimal trajectory from initial state to target
   */
  async planTrajectory(
    initialState: SpacecraftState,
    targetState: SpacecraftState,
    constraints?: TrajectoryConstraints
  ): Promise<TrajectoryPlan> {
    if (!this.solver || !this.graph) {
      throw new Error('Trajectory planner not initialized')
    }

    const startTime = performance.now()

    // Convert states to graph nodes
    const sourceNode = this.stateToNode(initialState)
    const targetNode = this.stateToNode(targetState)

    console.log(`Planning trajectory from node ${sourceNode} to ${targetNode}`)

    // Solve SSSP from source
    const result = this.solver.solve(sourceNode)

    // Extract optimal path to target
    const path = this.extractPath(result, targetNode)

    // Convert path to spacecraft states and maneuvers
    const { states, maneuvers } = this.pathToTrajectory(path, result)

    const planningTime = performance.now() - startTime

    return {
      states,
      maneuvers,
      totalCost: result.distances[targetNode],
      planningTime,
      algorithm: result.algorithm_used,
      performance: {
        nodesVisited: result.nodes_visited,
        edgesRelaxed: result.edges_relaxed
      }
    }
  }

  /**
   * Replan trajectory in real-time (for disturbance handling)
   */
  async replanTrajectory(
    currentState: SpacecraftState,
    originalPlan: TrajectoryPlan,
    disturbance: Vec3
  ): Promise<TrajectoryPlan> {
    // Apply disturbance to current state
    const disturbedState: SpacecraftState = {
      ...currentState,
      velocity: [
        currentState.velocity[0] + disturbance[0],
        currentState.velocity[1] + disturbance[1],
        currentState.velocity[2] + disturbance[2]
      ]
    }

    // Find target from original plan
    const remainingStates = originalPlan.states.filter(s => s.time > currentState.time)
    if (remainingStates.length === 0) {
      throw new Error('No remaining target states in original plan')
    }

    const nearestTarget = remainingStates[Math.floor(remainingStates.length / 2)]

    // Plan new trajectory from disturbed state
    return this.planTrajectory(disturbedState, nearestTarget)
  }

  /**
   * Benchmark performance against classical algorithms
   */
  async benchmarkPerformance(iterations: number = 100): Promise<BenchmarkResult> {
    if (!this.graph || !this.wasmModule) {
      throw new Error('Trajectory planner not initialized')
    }

    console.log(`Running benchmark with ${iterations} iterations...`)

    // Use center of state space as source
    const centerNode = Math.floor(this.graph.node_count / 2)

    const result = this.wasmModule.benchmark_algorithms(this.graph, centerNode, iterations)

    return {
      enhancedTimeMs: result.enhancedTimeMs,
      dijkstraTimeMs: result.dijkstraTimeMs,
      speedupFactor: result.speedupFactor,
      iterations: result.iterations,
      graphSize: {
        nodes: this.graph.node_count,
        edges: this.graph.edge_count
      }
    }
  }

  /**
   * Build trajectory planning graph from configuration
   */
  private buildTrajectoryGraph(): void {
    if (!this.wasmModule) {
      // For now, create a mock graph for testing
      this.createMockGraph()
      return
    }

    const { resolution, timeHorizon, timeStep, maxThrust, specificImpulse } = this.config
    const timeSteps = Math.floor(timeHorizon / timeStep)

    this.graph = this.wasmModule.TrajectoryGraphBuilder.build_trajectory_graph(
      resolution.position,
      resolution.velocity,
      timeSteps,
      maxThrust,
      specificImpulse
    )

    console.log(`Built trajectory graph: ${this.graph.node_count} nodes, ${this.graph.edge_count} edges`)
  }

  /**
   * Create mock graph for testing without WASM module
   */
  private createMockGraph(): void {
    const nodeCount = 1000
    const avgOutDegree = 4
    const edgeCount = nodeCount * avgOutDegree

    const outgoingEdges = new Uint32Array(nodeCount + 1)
    const destinations = new Uint32Array(edgeCount)
    const weights = new Float64Array(edgeCount)

    // Generate simple grid-like graph
    let edgeIdx = 0
    for (let node = 0; node < nodeCount; node++) {
      outgoingEdges[node] = edgeIdx

      // Add edges to neighboring nodes
      for (let i = 1; i <= avgOutDegree && edgeIdx < edgeCount; i++) {
        const neighbor = (node + i) % nodeCount
        destinations[edgeIdx] = neighbor
        weights[edgeIdx] = 1.0 + Math.random() * 10.0 // Random cost
        edgeIdx++
      }
    }
    outgoingEdges[nodeCount] = edgeIdx

    // Mock WasmSparseGraph interface
    this.graph = {
      node_count: nodeCount,
      edge_count: edgeIdx,
      validate: () => true
    } as WasmSparseGraph

    console.log(`Created mock graph: ${nodeCount} nodes, ${edgeIdx} edges`)
  }

  /**
   * Convert spacecraft state to graph node index
   */
  private stateToNode(state: SpacecraftState): number {
    // Simplified mapping - in practice would use proper discretization
    const { resolution, positionBounds, velocityBounds } = this.config

    // Normalize position to [0, 1]
    const posNorm = state.position.map((p, i) =>
      (p - positionBounds.min[i]) / (positionBounds.max[i] - positionBounds.min[i])
    )

    // Convert to discrete grid coordinates
    const posGrid = posNorm.map(p => Math.floor(p * resolution.position))

    // Similar for velocity
    const velNorm = state.velocity.map((v, i) =>
      (v - velocityBounds.min[i]) / (velocityBounds.max[i] - velocityBounds.min[i])
    )
    const velGrid = velNorm.map(v => Math.floor(v * resolution.velocity))

    // Time grid
    const timeGrid = Math.floor(state.time / this.config.timeStep)

    // Linear index (simplified)
    const nodeIndex = timeGrid * resolution.position * resolution.velocity +
                     posGrid[0] * resolution.velocity + velGrid[0]

    // Cache state for reverse lookup
    this.nodeToStateCache.set(nodeIndex, state)

    return Math.max(0, Math.min(nodeIndex, (this.graph?.node_count || 1000) - 1))
  }

  /**
   * Extract shortest path from SSSP result
   */
  private extractPath(result: WasmSSSpResult, target: number): number[] {
    const path: number[] = []
    let current = target

    while (current !== -1) {
      path.unshift(current)
      current = result.predecessors[current]
    }

    return path
  }

  /**
   * Convert graph path to spacecraft trajectory
   */
  private pathToTrajectory(path: number[], result: WasmSSSpResult): {
    states: SpacecraftState[]
    maneuvers: TrajectoryManeuver[]
  } {
    const states: SpacecraftState[] = []
    const maneuvers: TrajectoryManeuver[] = []

    for (let i = 0; i < path.length; i++) {
      const nodeId = path[i]

      // Get or reconstruct state from cache
      let state = this.nodeToStateCache.get(nodeId)
      if (!state) {
        // Reconstruct state from node ID (simplified)
        state = {
          position: [0, 0, 0],
          velocity: [0, 0, 0],
          time: i * this.config.timeStep,
          fuelMass: this.config.fuelCapacity,
          phase: LaunchPhase.STAGE1_BURN
        }
      }

      states.push(state)

      // Generate maneuver between consecutive states
      if (i > 0) {
        const prevState = states[i - 1]
        const maneuver = this.computeManeuver(prevState, state)
        maneuvers.push(maneuver)
      }
    }

    return { states, maneuvers }
  }

  /**
   * Compute required maneuver between two states
   */
  private computeManeuver(from: SpacecraftState, to: SpacecraftState): TrajectoryManeuver {
    const deltaV: Vec3 = [
      to.velocity[0] - from.velocity[0],
      to.velocity[1] - from.velocity[1],
      to.velocity[2] - from.velocity[2]
    ]

    const deltaVMagnitude = Math.sqrt(deltaV[0]**2 + deltaV[1]**2 + deltaV[2]**2)
    const burnDuration = deltaVMagnitude / (this.config.maxThrust / from.fuelMass)
    const fuelUsed = this.config.maxThrust * burnDuration / (this.config.specificImpulse * 9.81)

    return {
      time: from.time,
      deltaV,
      burnDuration,
      fuelUsed,
      cost: deltaVMagnitude * this.config.costs.fuelWeight +
            burnDuration * this.config.costs.timeWeight
    }
  }
}

/**
 * Trajectory planning constraints
 */
export interface TrajectoryConstraints {
  maxDeltaV?: number           // m/s, maximum total delta-V
  minFuelReserve?: number      // kg, minimum fuel to keep
  maxBurnDuration?: number     // s, maximum single burn duration
  avoidanceZones?: AvoidanceZone[]  // Regions to avoid
}

export interface AvoidanceZone {
  center: Vec3                 // m, zone center
  radius: number              // m, avoidance radius
  cost: number                // Additional cost for entering zone
}

/**
 * Performance benchmark result
 */
export interface BenchmarkResult {
  enhancedTimeMs: number
  dijkstraTimeMs: number
  speedupFactor: number
  iterations: number
  graphSize: {
    nodes: number
    edges: number
  }
}

/**
 * Default trajectory planning configuration for launch missions
 */
export const DEFAULT_LAUNCH_PLANNING_CONFIG: TrajectoryPlanningConfig = {
  positionBounds: {
    min: [6.3e6, -1e5, -1e5],     // Near Earth surface
    max: [7e6, 1e5, 1e5]          // Low Earth orbit
  },
  velocityBounds: {
    min: [-1e4, -1e4, -1e4],      // m/s
    max: [1e4, 1e4, 1e4]
  },
  timeHorizon: 1000,              // 1000 seconds
  timeStep: 10,                   // 10 second resolution
  fuelCapacity: 100000,           // 100 tons
  maxThrust: 7.6e6,              // Falcon 9 first stage
  specificImpulse: 282,           // Merlin engines
  dryMass: 25000,                // kg
  costs: {
    timeWeight: 1.0,
    fuelWeight: 10.0,
    riskWeight: 100.0
  },
  resolution: {
    position: 20,
    velocity: 15
  }
}
